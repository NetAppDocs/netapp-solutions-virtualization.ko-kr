---
sidebar: sidebar 
permalink: openshift/osv-vm-dp-using-tp.html 
keywords: OpenShift, OCP, Trident, Trident protect, NetApp ONTAP, Red Hat OpenShift, OpenShift Virtualization, CNV, Container Native Virtualization, Red Hat OpenShift Virtualization,Data Protection, Data Management for VMs, VM protection 
summary: NetApp ONTAP 통한 Red Hat OpenShift Virtualization 데이터 보호 
---
= Trident Protect를 사용하여 Red Hat OpenShift Virtualization에서 VM 보호
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
스냅샷과 백업을 사용하여 OpenShift Virtualization에서 VM을 보호합니다. 이 절차에는 ONTAP S3 개체 스토리지를 사용하여 AppVault를 만들고, Kubernetes 리소스 개체, 영구 볼륨, 내부 이미지를 비롯한 VM 데이터를 캡처하도록 Trident Protect를 구성하고, 필요한 경우 데이터를 복원하는 작업이 포함됩니다.

OpenShift 가상화 환경의 가상 머신은 OpenShift 컨테이너 플랫폼의 워커 노드에서 실행되는 컨테이너화된 애플리케이션입니다. VM 메타데이터와 VM의 영구 디스크를 보호하는 것은 손실되거나 손상될 경우 복구할 수 있도록 하는 데 중요합니다.

OpenShift Virtualization VM의 영구 디스크는 OpenShift 클러스터에 통합된 ONTAP 스토리지로 백업할 수 있습니다.link:https://docs.netapp.com/us-en/trident/["Trident CSI"] . 이 섹션에서는 다음을 사용합니다.link:https://docs.netapp.com/us-en/trident/trident-protect/learn-about-trident-protect.html["Trident 프로텍트"] 데이터 볼륨을 포함한 VM의 스냅샷과 백업을 ONTAP Object Storage에 생성합니다.

필요한 경우 스냅샷이나 백업에서 복원합니다.

Trident Protect를 사용하면 OpenShift 클러스터에서 애플리케이션과 VM의 스냅샷, 백업, 복원 및 재해 복구가 가능합니다. OpenShift Virtualization VM의 경우 Trident Protect로 보호할 수 있는 데이터에는 VM과 연결된 Kubernetes 리소스 개체, 영구 볼륨, 내부 이미지가 포함됩니다.

**다음은 이 섹션의 예제에 사용된 다양한 구성 요소의 버전입니다.**

* link:https://docs.redhat.com/en/documentation/openshift_container_platform/4.17/html/installing_on_bare_metal/index["오픈시프트 클러스터 4.17"]
* link:https://docs.redhat.com/en/documentation/openshift_container_platform/4.17/html/virtualization/getting-started#tours-quick-starts_virt-getting-started["Red Hat에서 제공하는 OpenShift Virtualization Operator를 통해 설치된 OpenShift Virtualization"]
* link:https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html["Trident 25.02"]
* link:https://docs.netapp.com/us-en/trident/trident-protect/trident-protect-installation.html["Trident 프로텍트 25.02"]
* link:https://docs.netapp.com/us-en/ontap/["ONTAP 9.16"]




== 개체 저장소용 App Vault 만들기

.AppVault 만들기
[%collapsible%open]
====
애플리케이션이나 VM에 대한 스냅샷과 백업을 생성하기 전에 Trident Protect에서 스냅샷과 백업을 저장할 개체 스토리지를 구성해야 합니다. 이 작업은 버킷 CR을 사용하여 수행됩니다. 관리자만 버킷 CR을 만들고 구성할 수 있습니다. Trident Protect에서는 버킷 CR을 AppVault라고 합니다. AppVault 객체는 스토리지 버킷의 선언적 Kubernetes 워크플로 표현입니다. AppVault CR에는 백업, 스냅샷, 복원 작업, SnapMirror 복제와 같은 보호 작업에 버킷을 사용하는 데 필요한 구성이 포함되어 있습니다.

이 예에서는 ONTAP S3를 개체 스토리지로 사용하는 방법을 보여드리겠습니다. ONTAP S3용 AppVault CR을 만드는 워크플로는 다음과 같습니다. 1. ONTAP 클러스터의 SVM에 S3 객체 저장 서버를 생성합니다. 2. Object Store Server에 버킷을 만듭니다. 3. SVM에서 S3 사용자를 생성합니다. 액세스 키와 비밀 키를 안전한 곳에 보관하세요. 4. OpenShift에서 ONTAP S3 자격 증명을 저장할 비밀을 만듭니다. 5. ONTAP S3에 대한 AppVault 개체 만들기

** ONTAP S3에 대한 Trident Protect AppVault 구성**

[source, yaml]
----
# alias tp='tridentctl-protect'

# cat appvault-secret.yaml
apiVersion: v1
stringData:
  accessKeyID: "<access key of S3>"
  secretAccessKey: "<secret access key of S3>"
# you can also provide base 64 encoded values instead of string values
#data:
# base 64 encoded values
#  accessKeyID: < base 64 encoded access key>
#  secretAccessKey: <base 64 encoded secretAccess key>
kind: Secret
metadata:
  name: appvault-secret
  namespace: trident-protect
type: Opaque

# cat appvault.yaml
apiVersion: protect.trident.netapp.io/v1
kind: AppVault
metadata:
  name: ontap-s3-appvault
  namespace: trident-protect
spec:
  providerConfig:
    azure:
      accountName: ""
      bucketName: ""
      endpoint: ""
    gcp:
      bucketName: ""
      projectID: ""
    s3:
      bucketName: trident-protect
      endpoint: <lif for S3 access>
      secure: "false"
      skipCertValidation: "true"
  providerCredentials:
    accessKeyID:
      valueFromSecret:
        key: accessKeyID
        name: appvault-secret
    secretAccessKey:
      valueFromSecret:
        key: secretAccessKey
        name: appvault-secret
  providerType: OntapS3

# oc create -f appvault-secret.yaml -n trident-protect
# oc create -f appvault.yaml -n trident-protect
----
image:rh-os-n-use-case-ocpv-tp-dp-008.png["ONTAP S3 Appvault가 생성되었습니다."]

====


== OpenShift Virtualization에서 VM 만들기

.OpenShift Virtualization에서 VM 만들기
[%collapsible%open]
====
다음 스크린샷은 템플릿을 사용하여 콘솔에서 VM(네임스페이스 demo의 demo-fedora)을 만드는 방법을 보여줍니다. 루트 디스크는 기본 저장소 클래스를 자동으로 선택하므로 기본 저장소 클래스가 적절하게 설정되었는지 확인하세요. 이 설정에서 기본 저장소 클래스는 **sc-zonea-san**입니다. 추가 디스크를 생성할 때 스토리지 클래스 sc-zonea-san을 선택하고 "**최적화된 스토리지 설정 적용**" 확인란을 선택하세요. 이렇게 하면 액세스 모드가 RWX로 설정되고 볼륨 모드가 차단으로 설정됩니다.


NOTE: Trident SAN(iSCSI, NVMe/TCP 및 FC)의 블록 볼륨 모드에서 RWX 액세스 모드를 지원합니다. (NAS의 기본 접속 모드입니다.) 나중에 VM의 라이브 마이그레이션을 수행해야 하는 경우 RWX 액세스 모드가 필요합니다.

image:rh-os-n-use-case-ocpv-tp-dp-001.png["기본 저장 클래스"]

image:rh-os-n-use-case-ocpv-tp-dp-002.png["페도라 VM 생성"]

image:rh-os-n-use-case-ocpv-tp-dp-003.png["템플릿 기본값"]

image:rh-os-n-use-case-ocpv-tp-dp-004.png["사용자 정의"]

image:rh-os-n-use-case-ocpv-tp-dp-005.png["디스크 추가"]

image:rh-os-n-use-case-ocpv-tp-dp-006.png["디스크가 추가되었습니다"]

image:rh-os-n-use-case-ocpv-tp-dp-007.png["vm, pods 및 pvc가 생성되었습니다."]

====


== 앱 만들기

.앱 만들기
[%collapsible%open]
====
**VM에 대한 Trident Protect 앱 만들기**

이 예에서 데모 네임스페이스에는 하나의 VM이 있으며, 앱을 생성할 때 네임스페이스의 모든 리소스가 포함됩니다.

[source, yaml]
----
# alias tp='tridentctl-protect'
# tp create app demo-vm --namespaces demo -n demo --dry-run > app.yaml

# cat app.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Application
metadata:
  creationTimestamp: null
  name: demo-vm
  namespace: demo
spec:
  includedNamespaces:
  - namespace: demo
# oc create -f app.yaml -n demo
----
image:rh-os-n-use-case-ocpv-tp-dp-009.png["앱이 생성되었습니다"]

====


== 백업을 만들어 앱을 보호하세요

.백업 만들기
[%collapsible%open]
====
**주문형 백업 만들기**

이전에 만든 앱(demo-vm)에 대한 백업을 만들고, 이 백업에는 demo 네임스페이스의 모든 리소스가 포함됩니다. 백업이 저장될 AppVault 이름을 입력하세요.

[source, yaml]
----
# tp create backup demo-vm-backup-on-demand --app demo-vm --appvault ontap-s3-appvault -n demo
Backup "demo-vm-backup-on-demand" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-015.png["주문형 백업이 생성되었습니다."]

**일정에 따라 백업 만들기**

보존할 백업의 세분성과 개수를 지정하여 백업 일정을 만듭니다.

[source, yaml]
----
# tp create schedule backup-schedule1 --app demo-vm --appvault ontap-s3-appvault --granularity Hourly --minute 45 --backup-retention 1 -n demo --dry-run>backup-schedule-demo-vm.yaml
schedule.protect.trident.netapp.io/backup-schedule1 created

#cat backup-schedule-demo-vm.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Schedule
metadata:
  creationTimestamp: null
  name: backup-schedule1
  namespace: demo
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: demo-vm
  backupRetention: "1"
  dayOfMonth: ""
  dayOfWeek: ""
  enabled: true
  granularity: Hourly
  hour: ""
  minute: "45"
  recurrenceRule: ""
  snapshotRetention: "0"
status: {}
# oc create -f backup-schedule-demo-vm.yaml -n demo
----
image:rh-os-n-use-case-ocpv-tp-dp-016.png["백업 일정이 생성되었습니다"]

image:rh-os-n-use-case-ocpv-tp-dp-017.png["수요에 따라 일정에 따라 백업이 생성됩니다."]

====


== 백업에서 복원

.백업에서 복원
[%collapsible%open]
====
**VM을 동일한 네임스페이스로 복원**

예시에서 백업 demo-vm-backup-on-demand에는 Fedora VM용 demo-app을 사용한 백업이 포함되어 있습니다.

먼저 VM을 삭제하고 PVC, Pod 및 VM 개체가 "demo" 네임스페이스에서 삭제되었는지 확인하세요.

image:rh-os-n-use-case-ocpv-tp-dp-019.png["fedora-vm 삭제됨"]

이제 백업-인-플레이스 복원 개체를 만듭니다.

[source, yaml]
----
# tp create bir demo-fedora-restore --backup demo/demo-vm-backup-on-demand -n demo --dry-run>vm-demo-bir.yaml

# cat vm-demo-bir.yaml
apiVersion: protect.trident.netapp.io/v1
kind: BackupInplaceRestore
metadata:
  annotations:
    protect.trident.netapp.io/max-parallel-restore-jobs: "25"
  creationTimestamp: null
  name: demo-fedora-restore
  namespace: demo
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/backups/demo-vm-backup-on-demand_f6af3513-9739-480e-88c7-4cca45808a80
  appVaultRef: ontap-s3-appvault
  resourceFilter: {}
status:
  postRestoreExecHooksRunResults: null
  state: ""

# oc create -f vm-demo-bir.yaml -n demo
backupinplacerestore.protect.trident.netapp.io/demo-fedora-restore created
----
image:rh-os-n-use-case-ocpv-tp-dp-020.png["새가 만들어졌다"]

VM, Pod 및 PVC가 복구되었는지 확인하세요.

image:rh-os-n-use-case-ocpv-tp-dp-021.png["VM이 복원되었습니다."]

**VM을 다른 네임스페이스로 복원**

먼저 앱을 복원할 새 네임스페이스를 만듭니다. 이 예에서는 demo2입니다. 그런 다음 백업 복원 개체를 만듭니다.

[source, yaml]
----
# tp create br demo2-fedora-restore --backup demo/hourly-4c094-20250312154500 --namespace-mapping demo:demo2 -n demo2 --dry-run>vm-demo2-br.yaml

# cat vm-demo2-br.yaml
apiVersion: protect.trident.netapp.io/v1
kind: BackupRestore
metadata:
  annotations:
    protect.trident.netapp.io/max-parallel-restore-jobs: "25"
  creationTimestamp: null
  name: demo2-fedora-restore
  namespace: demo2
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/backups/hourly-4c094-20250312154500_aaa14543-a3fa-41f1-a04c-44b1664d0f81
  appVaultRef: ontap-s3-appvault
  namespaceMapping:
  - destination: demo2
    source: demo
  resourceFilter: {}
status:
  conditions: null
  postRestoreExecHooksRunResults: null
  state: ""
# oc create -f vm-demo2-br.yaml -n demo2
----
image:rh-os-n-use-case-ocpv-tp-dp-022.png["br 생성됨"]

VM, Pod, PVC가 새 네임스페이스 demo2에 생성되었는지 확인합니다.

image:rh-os-n-use-case-ocpv-tp-dp-023.png["새 네임스페이스의 VM"]

====


== 스냅샷을 사용하여 앱 보호

.스냅샷 만들기
[%collapsible%open]
====
**주문형 스냅샷 만들기** 앱에 대한 스냅샷을 만들고 저장해야 하는 AppVault를 지정합니다.

[source, yaml]
----
# tp create snapshot demo-vm-snapshot-ondemand --app demo-vm --appvault ontap-s3-appvault -n demo --dry-run
# cat demo-vm-snapshot-on-demand.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Snapshot
metadata:
  creationTimestamp: null
  name: demo-vm-snapshot-ondemand
  namespace: demo
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: demo-vm
  completionTimeout: 0s
  volumeSnapshotsCreatedTimeout: 0s
  volumeSnapshotsReadyToUseTimeout: 0s
status:
  conditions: null
  postSnapshotExecHooksRunResults: null
  preSnapshotExecHooksRunResults: null
  state: ""

# oc create -f demo-vm-snapshot-on-demand.yaml
snapshot.protect.trident.netapp.io/demo-vm-snapshot-ondemand created

----
image:rh-os-n-use-case-ocpv-tp-dp-023.png["온디맨드 스냅샷"]

**스냅샷 일정 만들기** 스냅샷 일정을 만듭니다. 보존할 스냅샷의 세분성과 개수를 지정합니다.

[source, yaml]
----
# tp create Schedule snapshot-schedule1 --app demo-vm --appvault ontap-s3-appvault --granularity Hourly --minute 50 --snapshot-retention 1 -n demo --dry-run>snapshot-schedule-demo-vm.yaml

# cat snapshot-schedule-demo-vm.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Schedule
metadata:
  creationTimestamp: null
  name: snapshot-schedule1
  namespace: demo
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: demo-vm
  backupRetention: "0"
  dayOfMonth: ""
  dayOfWeek: ""
  enabled: true
  granularity: Hourly
  hour: ""
  minute: "50"
  recurrenceRule: ""
  snapshotRetention: "1"
status: {}

# oc create -f snapshot-schedule-demo-vm.yaml
schedule.protect.trident.netapp.io/snapshot-schedule1 created
----
image:rh-os-n-use-case-ocpv-tp-dp-025.png["스냅샷 일정"]

image:rh-os-n-use-case-ocpv-tp-dp-026.png["예약된 스냅샷"]

====


== 스냅샷에서 복원

.스냅샷에서 복원
[%collapsible%open]
====
**스냅샷에서 동일한 네임스페이스로 VM 복원** demo2 네임스페이스에서 VM demo-fedora를 삭제합니다.

image:rh-os-n-use-case-ocpv-tp-dp-030.png["VM 삭제"]

VM의 스냅샷에서 스냅샷-인-플레이스-복원 개체를 만듭니다.

[source, yaml]
----
# tp create sir demo-fedora-restore-from-snapshot --snapshot demo/demo-vm-snapshot-ondemand -n demo --dry-run>vm-demo-sir.yaml

# cat vm-demo-sir.yaml
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotInplaceRestore
metadata:
  creationTimestamp: null
  name: demo-fedora-restore-from-snapshot
  namespace: demo
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/snapshots/20250318132959_demo-vm-snapshot-ondemand_e3025972-30c0-4940-828a-47c276d7b034
  appVaultRef: ontap-s3-appvault
  resourceFilter: {}
status:
  conditions: null
  postRestoreExecHooksRunResults: null
  state: ""

# oc create -f vm-demo-sir.yaml
snapshotinplacerestore.protect.trident.netapp.io/demo-fedora-restore-from-snapshot created
----
image:rh-os-n-use-case-ocpv-tp-dp-027.png["선생님"]

VM과 해당 PVC가 데모 네임스페이스에 생성되었는지 확인합니다.

image:rh-os-n-use-case-ocpv-tp-dp-031.png["동일한 네임스페이스에서 vm이 복원되었습니다."]

**스냅샷에서 다른 네임스페이스로 VM 복원**

이전에 백업에서 복원한 demo2 네임스페이스의 VM을 삭제합니다.

image:rh-os-n-use-case-ocpv-tp-dp-028.png["VM, PVC 삭제"]

스냅샷에서 스냅샷 복원 개체를 만들고 네임스페이스 매핑을 제공합니다.

[source, yaml]
----
# tp create sr demo2-fedora-restore-from-snapshot --snapshot demo/demo-vm-snapshot-ondemand --namespace-mapping demo:demo2 -n demo2 --dry-run>vm-demo2-sr.yaml

# cat vm-demo2-sr.yaml
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotRestore
metadata:
  creationTimestamp: null
  name: demo2-fedora-restore-from-snapshot
  namespace: demo2
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/snapshots/20250318132959_demo-vm-snapshot-ondemand_e3025972-30c0-4940-828a-47c276d7b034
  appVaultRef: ontap-s3-appvault
  namespaceMapping:
  - destination: demo2
    source: demo
  resourceFilter: {}
status:
  postRestoreExecHooksRunResults: null
  state: ""

# oc create -f vm-demo2-sr.yaml
snapshotrestore.protect.trident.netapp.io/demo2-fedora-restore-from-snapshot created
----
image:rh-os-n-use-case-ocpv-tp-dp-029.png["SR이 생성되었습니다"]

VM과 해당 PVC가 새 네임스페이스 demo2에 복원되었는지 확인합니다.

image:rh-os-n-use-case-ocpv-tp-dp-032.png["새 네임스페이스에서 VM이 복원되었습니다."]

====


== 특정 VM 복원

.네임스페이스에서 특정 VM을 선택하여 스냅샷/백업을 생성하고 복원합니다.
[%collapsible%open]
====
이전 예에서는 네임스페이스 내에 단일 VM이 있었습니다. 백업에 전체 네임스페이스를 포함함으로써 해당 VM과 연관된 모든 리소스가 캡처되었습니다. 다음 예제에서는 동일한 네임스페이스에 다른 VM을 추가하고 레이블 선택기를 사용하여 이 새로운 VM에 대한 앱을 만듭니다.

**demo 네임스페이스에 새 VM(demo-centos vm)을 만듭니다.**

image:rh-os-n-use-case-ocpv-tp-dp-010.png["데모 네임스페이스의 demo-centos VM"]

***demo-centos vm 및 관련 리소스에 레이블을 지정합니다.***

image:rh-os-n-use-case-ocpv-tp-dp-011.png["레이블 demo-centos vm, pvc"]

***demo-centos vm 및 pvcs에 레이블이 지정되었는지 확인하세요.***

image:rh-os-n-use-case-ocpv-tp-dp-012.png["demo-centos vm 레이블"]

image:rh-os-n-use-case-ocpv-tp-dp-013.png["데모센토스 PVC에 라벨이 붙었어요"]

**레이블 선택기를 사용하여 특정 VM(demo-centos)에 대한 앱만 만들기**

[source, yaml]
----
# tp create app demo-centos-app --namespaces 'demo(category=protect-demo-centos)' -n demo --dry-run>demo-centos-app.yaml

# cat demo-centos-app.yaml

apiVersion: protect.trident.netapp.io/v1
kind: Application
metadata:
  creationTimestamp: null
  name: demo-centos-app
  namespace: demo
spec:
  includedNamespaces:
  - labelSelector:
      matchLabels:
        category: protect-demo-centos
    namespace: demo
status:
  conditions: null

# oc create -f demo-centos-app.yaml -n demo
application.protect.trident.netapp.io/demo-centos-app created
----
image:rh-os-n-use-case-ocpv-tp-dp-014.png["데모센토스 PVC에 라벨이 붙었어요"]

필요에 따라 일정에 따라 백업과 스냅샷을 만드는 방법은 이전에 보여준 것과 동일합니다. 스냅샷이나 백업을 생성하는 데 사용되는 trident-protect 앱에는 네임스페이스의 특정 VM만 포함되어 있으므로, 이를 복원하면 특정 VM만 복원됩니다. 아래는 백업/복원 작업의 예를 보여줍니다.

**해당 앱을 사용하여 네임스페이스의 특정 VM 백업을 만듭니다.**

이전 단계에서는 레이블 선택기를 사용하여 demo 네임스페이스에 centos vm만 포함하도록 앱을 만들었습니다. 이 앱에 대한 백업(이 예에서는 주문형 백업)을 만듭니다.

[source, yaml]
----
# tp create backup demo-centos-backup-on-demand --app demo-centos-app --appvault ontap-s3-appvault -n demo
Backup "demo-centos-backup-on-demand" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-018.png["특정 VM의 백업이 생성됨"]

**특정 VM을 동일한 네임스페이스로 복원** 특정 VM(centos)의 백업은 해당 앱을 사용하여 생성되었습니다. 여기에서 백업-인-플레이스-복원이나 백업-복원이 생성되면 해당 VM만 복원됩니다. Centos VM을 삭제합니다.

image:rh-os-n-use-case-ocpv-tp-dp-033.png["Centos VM 존재"]

image:rh-os-n-use-case-ocpv-tp-dp-034.png["Centos VM이 삭제되었습니다"]

demo-centos-backup-on-demand에서 백업 인플레이스 복원을 생성하고 CentOS VM이 다시 생성되었는지 확인합니다.

[source, yaml]
----
#tp create bir demo-centos-restore --backup demo/demo-centos-backup-on-demand -n demo
BackupInplaceRestore "demo-centos-restore" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-035.png["centos vm bir을 생성하세요"]

image:rh-os-n-use-case-ocpv-tp-dp-036.png["centos vm 생성됨"]

**특정 VM을 다른 네임스페이스로 복원** demo-centos-backup-on-demand에서 다른 네임스페이스(demo3)로 백업 복원을 만들고 centos VM이 다시 생성되었는지 확인합니다.

[source, yaml]
----
# tp create br demo2-centos-restore --backup demo/demo-centos-backup-on-demand --namespace-mapping demo:demo3 -n demo3
BackupRestore "demo2-centos-restore" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-037.png["centos vm bir을 생성하세요"]

image:rh-os-n-use-case-ocpv-tp-dp-038.png["centos vm 생성됨"]

====


== 비디오 데모

다음 비디오는 스냅샷을 사용하여 VM을 보호하는 방법을 보여줍니다.

.VM 보호
video::4670e188-3d67-4207-84c5-b2d500f934a0[panopto,width=360]